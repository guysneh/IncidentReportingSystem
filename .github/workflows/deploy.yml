name: Deploy IncidentReportingSystem (.NET 8) to Azure Web App

on:
  workflow_dispatch:

permissions:
  id-token: write
  contents: write

defaults:
  run:
    shell: bash

env:
  AZURE_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
  AZURE_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
  AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
  RESOURCE_GROUP: incident-rg
  WEBAPP_NAME: incident-api
  PROJECT_PATH: IncidentReportingSystem/IncidentReportingSystem.API/IncidentReportingSystem.API.csproj
  DB_PROJECT_PATH: IncidentReportingSystem/IncidentReportingSystem.Infrastructure/IncidentReportingSystem.Infrastructure.csproj
  KEY_VAULT_NAME: incident-kv
  PG_SERVER_NAME: incident-db
  TEMP_RULE_NAME: gh-runner-temp
  ADMIN_CONN_SECRET: PostgreSqlConnectionString
  BASE_URL: https://incident-api.azurewebsites.net

jobs:
  build-and-deploy:
    environment: production
    runs-on: ubuntu-latest
    outputs:
      current_sha: ${{ steps.rev.outputs.sha }}
    steps:
      # ----- Build artifacts -----
      - name: Checkout
        uses: actions/checkout@v4

      - name: Capture current revision
        id: rev
        run: echo "sha=$(git rev-parse HEAD)" >> "$GITHUB_OUTPUT"

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 8.0.x

      - name: Restore
        run: dotnet restore "${{ env.PROJECT_PATH }}"

      - name: Build
        run: dotnet build "${{ env.PROJECT_PATH }}" --configuration Release --no-restore

      - name: Publish
        run: dotnet publish "${{ env.PROJECT_PATH }}" --configuration Release --output ./publish --no-build

      - name: Zip artifact
        run: |
          cd publish
          zip -r ../app.zip .
          cd ..

      # ----- Azure login -----
      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ env.AZURE_CLIENT_ID }}
          tenant-id: ${{ env.AZURE_TENANT_ID }}
          subscription-id: ${{ env.AZURE_SUBSCRIPTION_ID }}

      # Utilities for later diagnostics
      - name: Install CLI helpers (jq, xmllint)
        run: |
          sudo apt-get update
          sudo apt-get install -y jq libxml2-utils

      # Guard: ignore cleanup line, but still block accidental colon-keys
      - name: Guard (no colon-based AppConfig keys)
        run: |
          set -e
          offenders=$(git grep -nE '^[^#]*AppConfig:[A-Za-z]' .github/workflows || true)
          offenders=$(echo "$offenders" | grep -v 'setting-names' || true)
          if [ -n "$offenders" ]; then
            echo "Found colon-based AppConfig keys in workflows. Replace ':' with '__' in these lines:"
            echo "$offenders"
            exit 1
          fi

      # ----- Open temporary firewall for runner IP (Postgres) -----
      - name: Detect runner public IP
        id: ip
        run: |
          RUNNER_IP=$(curl -s https://api.ipify.org)
          echo "ip=$RUNNER_IP" >> "$GITHUB_OUTPUT"
          echo "Runner IP: $RUNNER_IP"

      - name: Add temporary Postgres firewall rule (retry)
        run: |
          set +e
          for i in 1 2 3; do
            az postgres flexible-server firewall-rule create \
              --resource-group "${{ env.RESOURCE_GROUP }}" \
              --name "${{ env.PG_SERVER_NAME }}" \
              --rule-name "${{ env.TEMP_RULE_NAME }}" \
              --start-ip-address "${{ steps.ip.outputs.ip }}" \
              --end-ip-address "${{ steps.ip.outputs.ip }}" \
              --only-show-errors --output none && break
            echo "Retry $i creating firewall rule..."
            sleep 5
          done
          set -e

      # ----- EF Core migrations out-of-band (no migrations in app startup) -----
      - name: Install dotnet-ef
        run: |
          dotnet tool install -g dotnet-ef
          echo "$HOME/.dotnet/tools" >> "$GITHUB_PATH"

      - name: Fetch ADMIN connection string from Key Vault
        id: adminconn
        run: |
          set -e
          NAME="${{ env.ADMIN_CONN_SECRET }}"
          CONN=$(az keyvault secret show \
            --vault-name "${{ env.KEY_VAULT_NAME }}" \
            --name "$NAME" \
            --query value -o tsv)
          if [ -z "$CONN" ]; then
            echo "Secret $NAME is empty or missing in Key Vault ${{ env.KEY_VAULT_NAME }}"
            exit 1
          fi
          if [[ "$CONN" == *"__PORT__"* || "$CONN" == *"__HOST__"* || "$CONN" == *"__DB__"* ]]; then
            echo "Secret $NAME contains placeholders. Fix the secret value in Key Vault."
            exit 1
          fi
          echo "::add-mask::$CONN"
          echo "CONN=$CONN" >> "$GITHUB_ENV"

      - name: Apply EF migrations (explicit connection)
        env:
          DOTNET_NOLOGO: true
        run: |
          dotnet ef database update \
            --project "${{ env.DB_PROJECT_PATH }}" \
            --startup-project "${{ env.PROJECT_PATH }}" \
            --configuration Release \
            --connection "$CONN"

      # ----- Get App Configuration endpoint -----
      - name: Get App Configuration endpoint
        id: appcfg
        run: |
          set -e
          NAME="incident-appcfg"
          RG="${{ env.RESOURCE_GROUP }}"
          EP=$(az appconfig show --name "$NAME" --resource-group "$RG" --query endpoint -o tsv)
          if [ -z "$EP" ]; then
            echo "Could not resolve App Configuration endpoint for $NAME"
            exit 1
          fi
          echo "endpoint=$EP" >> "$GITHUB_OUTPUT"
          echo "AppConfig endpoint: $EP"

      # ----- Ensure AppConfig app settings on Web App -----
      - name: Ensure AppConfig bootstrap settings on Web App
        run: |
          set -e
          RG="${{ env.RESOURCE_GROUP }}"
          APP="${{ env.WEBAPP_NAME }}"
          EP="${{ steps.appcfg.outputs.endpoint }}"
          az webapp config appsettings set \
            --resource-group "$RG" \
            --name "$APP" \
            --settings \
              AppConfig__Enabled=true \
              AppConfig__Endpoint="$EP" \
            --output none
          az webapp config appsettings list -g "$RG" -n "$APP" -o table | egrep 'AppConfig__Enabled|AppConfig__Endpoint' || true

      # ----- Cleanup legacy colon-based keys (without writing ':' in YAML) -----
      - name: Cleanup legacy colon-based keys (correct)
        run: |
          KEY1=$(printf 'AppConfig:%s' 'Enabled')
          KEY2=$(printf 'AppConfig:%s' 'Endpoint')
          az webapp config appsettings delete \
            --resource-group "${{ env.RESOURCE_GROUP }}" \
            --name "${{ env.WEBAPP_NAME }}" \
            --setting-names "$KEY1" "$KEY2" || true

      # ----- Enforce runtime port settings for Linux Web App -----
      - name: Ensure runtime app settings (port)
        run: |
          az webapp config appsettings set \
            --resource-group "${{ env.RESOURCE_GROUP }}" \
            --name "${{ env.WEBAPP_NAME }}" \
            --settings \
              ASPNETCORE_URLS="http://0.0.0.0:8080" \
              WEBSITES_PORT="8080"

      - name: Print effective app settings (sanitized)
        run: |
          az webapp config appsettings list \
            -g "${{ env.RESOURCE_GROUP }}" \
            -n "${{ env.WEBAPP_NAME }}" \
            --query "[?name=='ASPNETCORE_URLS' || name=='WEBSITES_PORT' || name=='AppConfig__Enabled' || name=='AppConfig__Endpoint']" -o table

      # ----- Enable application logs (once) -----
      - name: Enable application logs
        run: |
          az webapp log config \
            -g "${{ env.RESOURCE_GROUP }}" \
            -n "${{ env.WEBAPP_NAME }}" \
            --application-logging filesystem \
            --level information

      # ----- Deploy ZIP to Web App -----
      - name: Deploy ZIP to Web App
        run: |
          az webapp deploy \
            --resource-group "${{ env.RESOURCE_GROUP }}" \
            --name "${{ env.WEBAPP_NAME }}" \
            --type zip \
            --src-path app.zip \
            --restart true \
            --async true

      # ----- Extended health check with state/backoff (up to 600s) -----
      - name: Wait for /health 200 (max 600s, backoff)
        run: |
          set -e
          URL="${{ env.BASE_URL }}/health"
          DEADLINE=$(( $(date +%s) + 600 ))
          SLEEP=2
          while true; do
            STATE=$(az webapp show -g "${{ env.RESOURCE_GROUP }}" -n "${{ env.WEBAPP_NAME }}" --query state -o tsv || echo "unknown")
            CODE=$(curl -s -o /dev/null -w "%{http_code}" "$URL" || true)
            echo "State=$STATE, /health HTTP=$CODE"
            if [ "$CODE" = "200" ]; then
              echo "Health OK"
              break
            fi
            if [ "$(date +%s)" -ge "$DEADLINE" ]; then
              echo "Health failed: last HTTP $CODE (State=$STATE)"
              exit 1
            fi
            sleep "$SLEEP"
            if [ "$SLEEP" -lt 30 ]; then SLEEP=$((SLEEP+3)); fi
          done

      # ----- Mark last-good (update tag) on success -----
      - name: Create immutable deploy tag
        if: success()
        run: |
          set -e
          TS=$(date -u +'%Y-%m-%dT%H-%MZ')
          SHA="${{ steps.rev.outputs.sha }}"
          SHA7=$(echo "$SHA" | cut -c1-7)
          TAG="deploy/prod/${TS}-${SHA7}"
          echo "TAG=$TAG" >> "$GITHUB_ENV"
          git tag -a "$TAG" "$SHA" -m "Production deploy $TS"
          git push origin "refs/tags/$TAG"
      
      - name: Update prod branch pointer (on success)
        if: success()
        run: |
          SHA="${{ steps.rev.outputs.sha }}"
          git push origin "$SHA:refs/heads/prod" -f

      # ----- Extra diagnostics on failure -----
      - name: Dump last logs on failure
        if: failure()
        run: |
          timeout 60 az webapp log tail \
            -g "${{ env.RESOURCE_GROUP }}" \
            -n "${{ env.WEBAPP_NAME }}" | tail -n 200 || true

      - name: Fetch Kudu credentials (on failure)
        if: failure()
        id: kudu
        run: |
          set -e
          PP=$(az webapp deployment list-publishing-profiles \
                --resource-group "${{ env.RESOURCE_GROUP }}" \
                --name "${{ env.WEBAPP_NAME }}" \
                --xml)
          USER=$(echo "$PP" | xmllint --xpath "string(//publishProfile[@publishMethod='MSDeploy']/@userName)" - 2>/dev/null)
          PASS=$(echo "$PP" | xmllint --xpath "string(//publishProfile[@publishMethod='MSDeploy']/@userPWD)" - 2>/dev/null)
          echo "::add-mask::$USER"
          echo "::add-mask::$PASS"
          echo "user=$USER" >> "$GITHUB_OUTPUT"
          echo "pass=$PASS" >> "$GITHUB_OUTPUT"

      - name: Fetch Kudu docker & environment logs (on failure)
        if: failure()
        env:
          KUSER: ${{ steps.kudu.outputs.user }}
          KPASS: ${{ steps.kudu.outputs.pass }}
          SCM: https://incident-api.scm.azurewebsites.net
        run: |
          set +e
          echo "==== KUDU /api/logs/docker ===="
          curl -s -u "$KUSER:$KPASS" "$SCM/api/logs/docker" | tail -n 500 || true
          echo
          echo "==== KUDU /api/environment (filtered) ===="
          curl -s -u "$KUSER:$KPASS" "$SCM/api/environment" | \
            jq '.system | {PORT: .PORT, ASPNETCORE_URLS: .ASPNETCORE_URLS, WEBSITE_SITE_NAME: .WEBSITE_SITE_NAME}' || true

      # ----- Always cleanup temporary Postgres firewall rule -----
      - name: Remove temporary Postgres firewall rule (retry, ignore errors)
        if: always()
        run: |
          set +e
          for i in 1 2 3; do
            az postgres flexible-server firewall-rule delete \
              --resource-group "${{ env.RESOURCE_GROUP }}" \
              --name "${{ env.PG_SERVER_NAME }}" \
              --rule-name "${{ env.TEMP_RULE_NAME }}" -y && break
            echo "Retry $i deleting firewall rule..."
            sleep 5
          done
          exit 0

  rollback:
    environment: production
    needs: build-and-deploy
    if: failure()
    runs-on: ubuntu-latest
    steps:
      - name: Checkout last-good (prod tag)
        uses: actions/checkout@v4
        with:
          ref: refs/tags/prod

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 8.0.x

      - name: Restore
        run: dotnet restore "${{ env.PROJECT_PATH }}"

      - name: Build
        run: dotnet build "${{ env.PROJECT_PATH }}" --configuration Release --no-restore

      - name: Publish
        run: dotnet publish "${{ env.PROJECT_PATH }}" --configuration Release --output ./publish --no-build

      - name: Zip artifact
        run: |
          cd publish
          zip -r ../app.zip .
          cd ..

      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ env.AZURE_CLIENT_ID }}
          tenant-id: ${{ env.AZURE_TENANT_ID }}
          subscription-id: ${{ env.AZURE_SUBSCRIPTION_ID }}

      - name: Roll back Web App to last-good build
        run: |
          az webapp deploy \
            --resource-group "${{ env.RESOURCE_GROUP }}" \
            --name "${{ env.WEBAPP_NAME }}" \
            --type zip \
            --src-path app.zip \
            --restart true \
            --async true

      - name: Verify /health after rollback
        run: |
          URL="${{ env.BASE_URL }}/health"
          for i in {1..60}; do
            CODE=$(curl -s -o /dev/null -w "%{http_code}" "$URL")
            echo "Rollback health [$i] => $CODE"
            [ "$CODE" = "200" ] && exit 0
            sleep 3
          done
          echo "Production still unhealthy after rollback"; exit 1
