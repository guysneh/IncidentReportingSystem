name: Provision DB Runtime User & Secret

on:
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

defaults:
  run:
    shell: bash

env:
  AZURE_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
  AZURE_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
  AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

  RESOURCE_GROUP: "incident-rg"
  KEY_VAULT_NAME: "incident-kv"
  PG_SERVER_NAME: "incident-db"

  # Existing admin secret (already in KV)
  ADMIN_CONN_SECRET: "PostgreSqlConnectionString"

  # New runtime artifacts to manage
  RUNTIME_DB_USER: "incident_user"
  RUNTIME_PWD_SECRET: "PostgresRuntimePassword"
  RUNTIME_CONN_SECRET: "PostgreSqlRuntimeConnectionString"

  TEMP_RULE_NAME: "gh-runner-temp"

jobs:
  provision-runtime:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ env.AZURE_CLIENT_ID }}
          tenant-id: ${{ env.AZURE_TENANT_ID }}
          subscription-id: ${{ env.AZURE_SUBSCRIPTION_ID }}

      - name: Detect runner public IP
        id: ip
        run: |
          RUNNER_IP=$(curl -s https://api.ipify.org)
          echo "ip=$RUNNER_IP" >> $GITHUB_OUTPUT

      - name: Add temporary Postgres firewall rule
        run: |
          az postgres flexible-server firewall-rule create \
            --resource-group "${{ env.RESOURCE_GROUP }}" \
            --name "${{ env.PG_SERVER_NAME }}" \
            --rule-name "${{ env.TEMP_RULE_NAME }}" \
            --start-ip-address "${{ steps.ip.outputs.ip }}" \
            --end-ip-address "${{ steps.ip.outputs.ip }}" \
            --only-show-errors --output none

      - name: Fetch admin connection string from Key Vault
        id: adminconn
        run: |
          CONN=$(az keyvault secret show --vault-name "$KEY_VAULT_NAME" --name "$ADMIN_CONN_SECRET" --query value -o tsv)
          echo "::add-mask::$CONN"
          {
            echo 'ADMIN_CONN<<EOF'
            echo "$CONN"
            echo EOF
          } >> $GITHUB_ENV

      - name: Parse admin connection
        id: parse
        run: |
          host=$(echo "$ADMIN_CONN" | sed -n 's/.*Host=\([^;]*\).*/\1/p')
          db=$(echo "$ADMIN_CONN"   | sed -n 's/.*Database=\([^;]*\).*/\1/p')
          echo "host=$host" >> $GITHUB_OUTPUT
          echo "db=$db"     >> $GITHUB_OUTPUT

      - name: Ensure runtime password secret exists
        id: runtimepwd
        run: |
          set -e
          if az keyvault secret show --vault-name "$KEY_VAULT_NAME" --name "$RUNTIME_PWD_SECRET" &>/dev/null; then
            pwd=$(az keyvault secret show --vault-name "$KEY_VAULT_NAME" --name "$RUNTIME_PWD_SECRET" --query value -o tsv)
          else
            pwd=$(openssl rand -base64 32 | tr -d '\n' | sed 's/[^a-zA-Z0-9]/x/g')
            az keyvault secret set --vault-name "$KEY_VAULT_NAME" --name "$RUNTIME_PWD_SECRET" --value "$pwd" --output none
          fi
          echo "::add-mask::$pwd"
          echo "pwd=$pwd" >> $GITHUB_OUTPUT

      - name: Create/alter runtime user and grants (psql via Docker)
        env:
          ADMIN_CONN: ${{ env.ADMIN_CONN }}
          RUNTIME_DB_USER: ${{ env.RUNTIME_DB_USER }}
          RUNTIME_PWD: ${{ steps.runtimepwd.outputs.pwd }}
          DB_NAME: ${{ steps.parse.outputs.db }}
        run: |
          docker run --rm -i \
            -e ADMIN_CONN \
            -e RUNTIME_DB_USER \
            -e RUNTIME_PWD \
            -e DB_NAME \
            postgres:15 bash <<'BASH'
          set -euo pipefail

          ADMIN_URI="$ADMIN_CONN"

          cat > /tmp/step1.sql <<SQL
          DO \$do\$
          BEGIN
            IF NOT EXISTS (SELECT FROM pg_roles WHERE rolname = '${RUNTIME_DB_USER}') THEN
              EXECUTE format('CREATE ROLE %I LOGIN PASSWORD %L', '${RUNTIME_DB_USER}', '${RUNTIME_PWD}');
            ELSE
              EXECUTE format('ALTER ROLE %I WITH PASSWORD %L', '${RUNTIME_DB_USER}', '${RUNTIME_PWD}');
            END IF;
          END
          \$do\$;
          SQL

          psql "$ADMIN_URI" -v ON_ERROR_STOP=1 -f /tmp/step1.sql

          psql "$ADMIN_URI" -v ON_ERROR_STOP=1 -c "GRANT CONNECT ON DATABASE \"$DB_NAME\" TO ${RUNTIME_DB_USER};"

          cat > /tmp/step3.sql <<SQL
          GRANT USAGE ON SCHEMA public TO ${RUNTIME_DB_USER};
          GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA public TO ${RUNTIME_DB_USER};
          GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA public TO ${RUNTIME_DB_USER};

          ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT SELECT, INSERT, UPDATE, DELETE ON TABLES TO ${RUNTIME_DB_USER};
          ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT USAGE, SELECT ON SEQUENCES TO ${RUNTIME_DB_USER};
          SQL

          psql "$ADMIN_URI" -v ON_ERROR_STOP=1 -d "$DB_NAME" -f /tmp/step3.sql
          BASH

      - name: Upsert runtime connection string secret
        run: |
          RUNTIME_CONN="Host=${{ steps.parse.outputs.host }};Database=${{ steps.parse.outputs.db }};Username=${{ env.RUNTIME_DB_USER }};Password=${{ steps.runtimepwd.outputs.pwd }};Ssl Mode=Require;"
          echo "::add-mask::$RUNTIME_CONN"
          az keyvault secret set --vault-name "$KEY_VAULT_NAME" --name "$RUNTIME_CONN_SECRET" --value "$RUNTIME_CONN" --output none

      - name: Remove temporary Postgres firewall rule
        if: always()
        run: |
          az postgres flexible-server firewall-rule delete \
            --resource-group "${{ env.RESOURCE_GROUP }}" \
            --name "${{ env.PG_SERVER_NAME }}" \
            --rule-name "${{ env.TEMP_RULE_NAME }}" -y


